"use server";

import { createClient } from "@/lib/supabase/server";
import { revalidatePath } from "next/cache";
import { 
  sanitizeText, 
  validateOptions, 
  validateQuestion, 
  validatePollId
} from "../utils/poll-validation";
import {
  validatePollOption,
  userOwnsPoll,
  hasUserVoted
} from "../utils/poll-validation-server";
import { checkPollActionRateLimit, logSecurityEvent } from "../utils/security";

// CREATE POLL
export async function createPoll(formData: FormData) {
  try {
    const supabase = await createClient();

    // Get and sanitize input
    const rawQuestion = formData.get("question") as string;
    const rawOptions = formData.getAll("options").filter(Boolean) as string[];
    
    // Sanitize the question
    const question = sanitizeText(rawQuestion);
    
    // Validate question
    const questionValidation = validateQuestion(question);
    if (!questionValidation.isValid) {
      return { error: questionValidation.message };
    }
    
    // Validate options
    const optionsValidation = validateOptions(rawOptions);
    if (!optionsValidation.isValid) {
      return { error: optionsValidation.message };
    }
    
    // Use sanitized options
    const options = optionsValidation.sanitizedOptions || [];

    // Get user from session
    const {
      data: { user },
      error: userError,
    } = await supabase.auth.getUser();
    
    if (userError) {
      logSecurityEvent('create_poll_error', false, { 
        details: `Authentication error: ${userError.message}` 
      });
      return { error: "Authentication error. Please try again." };
    }
    
    if (!user) {
      logSecurityEvent('create_poll_unauthorized', false, { 
        details: 'Attempt to create poll without authentication' 
      });
      return { error: "You must be logged in to create a poll." };
    }
    
    // Check rate limiting
    if (!await checkPollActionRateLimit(user.id, 'createPoll')) {
      await logSecurityEvent('create_poll_rate_limited', false, { 
        userId: user.id, 
        details: 'Rate limit exceeded for poll creation' 
      });
      return { error: "You're creating polls too quickly. Please try again later." };
    }

    // First insert the poll
    const { error: pollError, data: pollData } = await supabase.from("polls").insert([
      {
        creator_id: user.id,
        title: question,
        description: null,
        allow_multiple_choices: false
      },
    ]).select('id').single();
    
    if (pollError) {
      logSecurityEvent('create_poll_error', false, { 
        userId: user.id, 
        details: `Poll insertion error: ${pollError.message}` 
      });
      return { error: "Failed to create poll. Please try again." };
    }
    
    // Then insert the options
    const pollOptionsData = options.map((option, index) => ({
      poll_id: pollData.id,
      text: option,
      order_index: index
    }));
    
    const { error } = await supabase.from("poll_options").insert(pollOptionsData);

    if (error) {
      logSecurityEvent('create_poll_error', false, { 
        userId: user.id, 
        details: `Database error: ${error.message}` 
      });
      return { error: "Failed to create poll. Please try again." };
    }

    // Log successful poll creation
    logSecurityEvent('create_poll_success', true, { 
      userId: user.id, 
      pollId: pollData.id,
      details: `Poll created successfully` 
    });

    revalidatePath("/polls");
    return { error: null };
  } catch (err) {
    console.error('Unhandled error in createPoll:', err);
    logSecurityEvent('create_poll_error', false, { 
      details: `Unhandled error: ${err instanceof Error ? err.message : String(err)}` 
    });
    return { error: "An unexpected error occurred. Please try again." };
  }
}

// GET POLL BY ID
export async function getPollById(id: string) {
  try {
    // Validate poll ID format
    if (!validatePollId(id)) {
      logSecurityEvent('get_poll_by_id_error', false, { 
        details: `Invalid poll ID format: ${id}` 
      });
      return { poll: null, error: "Invalid poll ID" };
    }

    const supabase = await createClient();
    
    // Get current user (if logged in)
    const { data: { user } } = await supabase.auth.getUser();
    
    // Use the get_poll_with_results function to get poll with options
    const { data, error } = await supabase
      .rpc('get_poll_with_results', { poll_uuid: id });

    if (error) {
      // Don't expose detailed database errors to the client
      if (error.code === 'PGRST116') {
        // Record not found error
        logSecurityEvent('get_poll_by_id_not_found', false, { 
          pollId: id,
          userId: user?.id,
          details: `Poll not found: ${id}` 
        });
        return { poll: null, error: "Poll not found" };
      } else {
        logSecurityEvent('get_poll_by_id_error', false, { 
          pollId: id,
          userId: user?.id,
          details: `Database error: ${error.message}` 
        });
        return { poll: null, error: "Failed to retrieve poll. Please try again." };
      }
    }
    
    // Format the poll data for consumption by client
    if (data && data.length > 0) {
      // Group the data by poll information
      const pollData = {
        id: data[0].poll_id,
        title: data[0].title,
        description: data[0].description,
        creator_id: data[0].creator_id,
        is_active: data[0].is_active,
        allow_multiple_choices: data[0].allow_multiple_choices,
        created_at: data[0].created_at,
        updated_at: data[0].updated_at,
        expires_at: data[0].expires_at,
        options: data.map(row => ({
          id: row.option_id,
          text: row.option_text,
          poll_id: row.poll_id,
          order_index: row.order_index,
          vote_count: row.vote_count || 0
        })),
        total_votes: data[0].total_votes || 0
      };
      
      return { poll: pollData, error: null };
    }
    
    return { poll: null, error: "Poll not found" };
  } catch (err) {
    console.error('Unhandled error in getPollById:', err);
    logSecurityEvent('get_poll_by_id_error', false, { 
      details: `Unhandled error: ${err instanceof Error ? err.message : String(err)}`,
      pollId: id 
    });
    return { poll: null, error: "An unexpected error occurred. Please try again." };
  }
}

// SUBMIT VOTE
export async function submitVote(pollId: string, optionId: string) {
  try {
    // Validate poll ID format
    if (!validatePollId(pollId)) {
      logSecurityEvent('submit_vote_error', false, { 
        pollId,
        details: `Invalid poll ID format: ${pollId}` 
      });
      return { error: "Invalid poll ID" };
    }

    // Validate option ID format
    if (!validatePollId(optionId)) {
      logSecurityEvent('submit_vote_error', false, { 
        pollId,
        details: `Invalid option ID format: ${optionId}` 
      });
      return { error: "Invalid option ID" };
    }

    const supabase = await createClient();
    
    // Get current user (if logged in)
    const {
      data: { user },
      error: userError
    } = await supabase.auth.getUser();

    if (userError) {
      logSecurityEvent('submit_vote_error', false, { 
        pollId,
        details: `Authentication error: ${userError.message}` 
      });
      // Continue as anonymous if there's an auth error but don't expose the error
    }

    // Validate the option belongs to this poll
    const optionValidation = await validatePollOption(pollId, optionId, supabase);
    if (!optionValidation.isValid) {
      logSecurityEvent('submit_vote_error', false, { 
        pollId,
        userId: user?.id,
        details: optionValidation.message 
      });
      return { error: optionValidation.message };
    }

    // If user is logged in, check if they've already voted
    if (user) {
      const alreadyVoted = await hasUserVoted(pollId, user.id, supabase);
      if (alreadyVoted) {
        logSecurityEvent('submit_vote_duplicate', false, { 
          pollId,
          userId: user.id,
          details: 'User attempted to vote multiple times' 
        });
        return { error: "You have already voted on this poll" };
      }
      
      // Check rate limiting for logged-in users
      if (!await checkPollActionRateLimit(user.id, 'votePoll')) {
        await logSecurityEvent('submit_vote_rate_limited', false, { 
          pollId,
          userId: user.id, 
          details: 'Rate limit exceeded for voting' 
        });
        return { error: "You're voting too quickly. Please try again later." };
      }
    }

    // Insert vote into database
    const { error } = await supabase.from("votes").insert([
      {
        poll_id: pollId,
        option_id: optionId,
        user_id: user?.id ?? null,
        // IP address and user agent would be handled by server middleware
      },
    ]);

    if (error) {
      logSecurityEvent('submit_vote_error', false, { 
        pollId,
        userId: user?.id,
        details: `Database error: ${error.message}` 
      });
      return { error: "Failed to submit vote. Please try again." };
    }

    // Log successful vote
    logSecurityEvent('submit_vote_success', true, { 
      pollId,
      userId: user?.id,
      details: `Vote submitted successfully for option ${optionId}` 
    });
    
    revalidatePath(`/polls/${pollId}`);
    return { error: null };
  } catch (err) {
    console.error('Unhandled error in submitVote:', err);
    logSecurityEvent('submit_vote_error', false, { 
      pollId,
      details: `Unhandled error: ${err instanceof Error ? err.message : String(err)}` 
    });
    return { error: "An unexpected error occurred. Please try again." };
  }
}

// DELETE POLL
export async function deletePoll(id: string) {
  try {
    // Validate poll ID format
    if (!validatePollId(id)) {
      logSecurityEvent('delete_poll_error', false, { 
        pollId: id,
        details: `Invalid poll ID format: ${id}` 
      });
      return { error: "Invalid poll ID" };
    }

    const supabase = await createClient();
    
    // Get current user
    const {
      data: { user },
      error: userError
    } = await supabase.auth.getUser();
    
    if (userError || !user) {
      logSecurityEvent('delete_poll_unauthorized', false, { 
        pollId: id,
        details: 'Attempt to delete poll without authentication' 
      });
      return { error: "You must be logged in to delete a poll" };
    }
    
    // Check if user owns the poll
    const isOwner = await userOwnsPoll(id, user.id, supabase);
    if (!isOwner) {
      logSecurityEvent('delete_poll_unauthorized', false, { 
        pollId: id,
        userId: user.id,
        details: 'User attempted to delete a poll they do not own' 
      });
      return { error: "You don't have permission to delete this poll" };
    }
    
    // Check rate limiting
    if (!await checkPollActionRateLimit(user.id, 'deletePoll')) {
      await logSecurityEvent('delete_poll_rate_limited', false, { 
        pollId: id,
        userId: user.id, 
        details: 'Rate limit exceeded for poll deletion' 
      });
      return { error: "You're making too many deletion requests. Please try again later." };
    }
    
    // Delete the poll (cascade will handle options and votes)
    const { error } = await supabase.from("polls").delete().eq("id", id);
    
    if (error) {
      logSecurityEvent('delete_poll_error', false, { 
        pollId: id,
        userId: user.id,
        details: `Database error: ${error.message}` 
      });
      return { error: "Failed to delete poll. Please try again." };
    }
    
    // Log successful deletion
    logSecurityEvent('delete_poll_success', true, { 
      pollId: id,
      userId: user.id,
      details: 'Poll deleted successfully' 
    });
    
    revalidatePath("/polls");
    return { error: null };
  } catch (err) {
    console.error('Unhandled error in deletePoll:', err);
    logSecurityEvent('delete_poll_error', false, { 
      details: `Unhandled error: ${err instanceof Error ? err.message : String(err)}` 
    });
    return { error: "An unexpected error occurred. Please try again." };
  }
}
